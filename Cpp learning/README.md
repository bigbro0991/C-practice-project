# 核心编程：

- C++中在程序运行前分为全局区和代码区
- 代码区特点是共享和只读
- 全局区中存放全局变量、静态变量、常量，（全局区的数据当程序运行完才释放）
- 常量区中存放 const修饰的全局常量 和 字符串常量

### 栈区：

栈（Stack）是用来静态分配内存的而堆是动态分配内存的，它们都是存在于计算机内存之中。
 栈的分配是在程序编译的时候完成的，直接存储在内存中，接触内存很快。栈是后进先出的顺序，最后被申请的块最先被释放，这样就很容易跟踪到栈，释放栈的过程简单到仅仅是移动下指针就能完成。

- 面向线程，栈区的数据还函数执行完自动释放
- 形参，局部变量，也会放在栈区
- 栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
   当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
- 栈区数据注意事项：不要返回局部变量地址；第一次保留，第二次就释放。
   - 常量区中存放 const 修饰的全局常量 和 字符串常量

   ### 堆区：

堆（heap）的分配是在程序运行时完成的，分配速度较为缓慢，但是堆的可用空间非常的大。堆中的元素相互之间没有关联，各自都可以被任何时候随机访问。我们可以任何时候申请和释放一块内存，这样会使得我们很难随时随地追踪到堆中某块位置被分配了还是被释放了。
 当你知道在编译前需要分配多少数据时且数据量不是很大时可以使用栈。如果不知道在运行时需要多少数据那么就该使用堆。

- 堆区数据由程序员管理开辟和释放
- 堆区数据利用new关键字进行开辟内存

### new 运算符

在heap区开辟数据和数组等

new 数据类型

```c++
//ex：
new int[10] // return consecutive area
new int(10) // return the pointer to this int
```

- 堆区数据由程序员管理开辟和释放(new 开辟，delete 释放)
- 堆区数据利用new关键字进行开辟内存
- delete p or delete[] arr

### 引用

##### 作用：给变量起别名

##### 语法：数据类型 &别名 = 原名

```c++
int a = 10;
//a---->[10]
//b---->[10]同一块
int &b = a;
b=20;//== (a=20);
```

##### 注意事项：

- 引用必须要初始化，必须开始说明它是谁的别名
- 一旦初始化，就不可以更改，别名初始化后不能变成别人的别名

#### 引用做函数参数

##### 作用：让形参修饰实参

##### 优点：简化指针修改实参

```c++
//main里的实参a,b 直接传入，由别名修饰，改变的话实参改变
//别名可以和原名一样
void swap(&a,&b)
{
	int temp = a;
	a = b;
	b = temp
}
```

>  总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单

#### 引用做函数参数

##### 作用：引用是可以作为函数的返回值存在的

##### 注意：**不要返回局部变量引用**

##### 用法：函数调用作为左值

如果函数的返回值是引用，这个函数调用可以作为左值。进行赋值的操作。

```c++
//返回局部变量引用
int& test01() {
	int a = 10; //局部变量
	return a;
}

//返回静态变量引用
int& test02() {
	static int a = 20;
	return a;
}

int main() {

	//不能返回局部变量的引用
	int& ref = test01();
	cout << "ref = " << ref << endl;
	cout << "ref = " << ref << endl;

	//如果函数做左值，那么必须返回引用
	int& ref2 = test02();
	cout << "ref2 = " << ref2 << endl;
	cout << "ref2 = " << ref2 << endl;

	test02() = 1000;

	cout << "ref2 = " << ref2 << endl;
	cout << "ref2 = " << ref2 << endl;

	system("pause");

	return 0;
}
```

#### 引用的本质

##### 本质：引用的本质是指针常量

引用必须引用一块合法的内存空间 

```c++
//发现是引用，转换为 int* const ref = &a;
void func(int& ref){
	ref = 100; // ref是引用，转换为*ref = 100
}
int main(){
	int a = 10;
    
    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
	int& ref = a; 
	ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;
    
	cout << "a:" << a << endl;
	cout << "ref:" << ref << endl;
    
	func(a);
	return 0;
}
```

#### 常量引用

**作用：**常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加==const修饰形参==，防止形参改变实参

**示例：**

```c++
//引用使用的场景，通常用来修饰形参
void showValue(const int& v) {
	//v += 10;
	cout << v << endl;
}

int main() {

	//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误
	//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;
	const int& ref = 10;

	//ref = 100;  //加入const后不可以修改变量
	cout << ref << endl;

	//函数中利用常量引用防止误操作修改实参
	int a = 10;
	showValue(a);

	system("pause");

	return 0;
}
```

### 函数提高

##### 函数默认参数：函数声明和函数实现只有一个能拥有默认参数。



##### 函数占位参数：占位参数必须填补 返回值类型 函数名（数据类型）{} -->用数据类型来占位。 占位参数也可以有默认参数。



##### 函数重载：

- 同一个作用域下
- 函数名相同 提高复用性
- 函数参数类型不同，或者个数不同，或者顺序不同--->用来分别不同，相当于多音字，不同情况，不同用法。 





### 类和对象

C ++ 面向对象三大特性：封装，继承，多态。

C++ 认为万事万物都是对象，对象上有其属性和行为。





#### 封装

##### 封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制



##### 类在设计时，可以把属性和行为放在不同的权限下，加以控制

##### 访问权限有三种：

1. public 公共权限
2. protected 保护权限
3. private 私有权限





#### struct和class区别

C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**

区别：

- struct 默认权限为公共
- class 默认权限为私有



#### 成员属性设置为私有

**优点1：**将所有成员属性设置为私有，可以自己控制读写权限

**优点2：**对于写权限，我们可以检测数据的有效性



#### 对象的初始化和清理

C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。

#### 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题

 一个对象或者变量没有初始状态，对其使用后果是未知

 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

c++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**



**编译器提供的构造函数和析构函数是空实现。**

- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次



**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号 ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

#### 构造函数的分类及调用

两种分类方式：

 按参数分为： 有参构造和无参构造

 按类型分为： 普通构造和拷贝构造

三种调用方式：

 括号法		  Person p1(10);

 显示法          Person p2 = Person(10); 

 隐式转换法   Person p4 = 10; ==//Person p4 = Person(10); 



#### 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况

- 使用一个已经创建完毕的对象来初始化一个新对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

Vscode优化了第三种返回值操作，只调V用默认构造函数；



#### 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1．默认构造函数(无参，函数体为空)

2．默认析构函数(无参，函数体为空)

3．默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：

- 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数，c++不会再提供其他构造函数

#### 深拷贝与浅拷贝

深浅拷贝是面试经典问题，也是常见的一个坑

浅拷贝：简单的赋值拷贝操作(编译器提供的等号的拷贝)

深拷贝：在堆区重新申请空间，进行拷贝操作

如果利用编译器提供的拷贝函数，会做浅拷贝---会出现问题，堆区的内容重复释放

因为当进行拷贝构造的时候，进行的浅拷贝，只复制了指向堆区的地址，第一次释放，就把指定堆区释放干净了，第二次释放就是非法操作。

析构函数作用：把深拷贝申请到的空间释放掉。

利用深拷贝来解决：重新申请一块堆区存放一样的数据

自己实现拷贝函数，解决浅拷贝问题。

```c++
Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height)
```

> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题



#### 初始化列表

相比构造函数，另一种对象初始化的方法。

**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`



#### 类对象作为类成员

C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员

```c++
class A {}
class B
{
    A a；
}
```

B类中有对象A作为成员，A为对象成员

构造函数 先调用对象成员 再调用 对象

当其它类对象作为本类成员，构造时先构造类对象，再构造自身，析构顺序与构造相反。



#### 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - 类内声明，类外初始化
- 静态成员函数
  - 所有对象共享同一个函数
  - 静态成员函数只能访问静态成员变量

静态函数在内存里只有一份，当对象调用这个函数体，函数体不知道函数内的变量属于哪一个对象，无法区分，因此静态函数里只能改变静态变量，静态成员函数无法区分函数体内的变量归属。

### C++对象模型和this指针



#### 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上



####  this指针概念

我们知道在C++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？

c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**

this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可

this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 在类的非静态成员函数中返回对象本身，可使用return *this

> 6sixth/this_pointer.cpp

#### 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有 用到this指针

如果用到this指针，需要加以判断保证代码的健壮性



#### const修饰成员函数

**常函数：**

- 成员函数后加const后我们称为这个函数为**常函数**
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字mutable后，在常函数中依然可以修改

**常对象：**

- 声明对象前加const称该对象为常对象
- 常对象只能调用常函数





### 友元

友元的目的就是让一个函数或者类 访问另一个类中私有成员

友元的关键字为 ==friend==

- 全局函数做友元
- 类做友元
- 成员函数做友元





### 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型



#### 加号运算符重载

作用：实现两个自定义数据类型相加的运算

也可以实现函数重载，多次利用operator

类型 operator+()

> 8eighth/operator.cpp



#### 左移运算符重载

作用：可以输出自定义数据类型

ostream & 类型 operator<<()

> 总结：重载左移运算符配合友元可以实现输出自定义数据类型
>
> 

#### 递增运算符重载

作用： 通过重载递增运算符，实现自己的整型数据



#### 赋值运算符重载

c++编译器至少给一个类添加4个函数

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符 operator=, 对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题



#### 关系运算符重载

**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作

#### 函数调用运算符重载

- 函数调用运算符 () 也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为仿函数
- 仿函数没有固定写法，非常灵活

```c++
![1544861202252](C:\Users\29444\Desktop\1544861202252.png)class MyPrint
{
public:
	void operator()(string text)
	{
		cout << text << endl;
	}

};
void test01()
{
	//重载的（）操作符 也称为仿函数
	MyPrint myFunc;
	myFunc("hello world");
}


class MyAdd
{
public:
	int operator()(int v1, int v2)
	{
		return v1 + v2;
	}
};

void test02()
{
	MyAdd add;
	int ret = add(10, 10);
	cout << "ret = " << ret << endl;

	//匿名对象调用  
	cout << "MyAdd()(100,100) = " << MyAdd()(100, 100) << endl;
}

int main() {

	test01();
	test02();

	system("pause");

	return 0;
}
```



### 继承

**继承是面向对象三大特性之一**

有些类与类之间存在特殊的关系，例如下图中:![image](https://github.com/bigbro0991/CPP-practice-project/blob/master/Cpp%20learning/1544861202252.png)

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。

这个时候我们就可以考虑利用继承的技术，减少重复代码
